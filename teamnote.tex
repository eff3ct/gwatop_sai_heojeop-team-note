\documentclass[10pt,landscape,a4paper,twocolumn]{article}

\setlength{\columnsep}{20pt}

\usepackage[left=1.0cm, right=1.0cm, top=1.5cm, bottom=1.0cm, headsep=0.4cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fontspec}
\usepackage{kotex}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{listings}
\usepackage{import}
\usepackage{url}
\usepackage{array}
\usepackage[normal]{engord}
\usepackage[svgnames,table]{xcolor}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[R]{\thepage}
\fancyhead[L]{Hanyang Univ. - 과탑사이허접}

\setmonofont[
    BoldFont = consolab.ttf,
    ItalicFont = consolai.ttf
]{consola.ttf}
\setmainhangulfont{Malgun Gothic}
\setlength\parindent{0pt}
\usepackage[parfill]{parskip}

\definecolor{dkgrey}{RGB}{127, 127, 127}

\lstset{
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    breakindent=1.1em
%    numbers=left,
%    numberstyle=\footnotesize\ttfamily\color{dkgrey},
%    numbersep=5pt
%    frame=trbl
}

\lstdefinestyle{mycpp}{
  language=[GNU]C++,
  keywordstyle=\color{blue},
  commentstyle=\itshape\color{purple!40!black},
  stringstyle=\color{orange},
}

\begin{document}

\section{Math}

\subsection{Gauss-Jordan Elimination}
\lstinputlisting[style=mycpp]{src/math/Gauss-Jordan-Elimination.cpp}

\subsection{Miller-Rabin Prime Test}
\lstinputlisting[style=mycpp]{src/math/Miller-Rabin-Prime-Test.cpp}

\subsection{Fast-Fourier-Transform}
\lstinputlisting[style=mycpp]{src/math/Cooley-Tukey(FFT).cpp}

\subsection{수학 관련 노트}
1. 모듈러 역원은 M이 소수일 때, $a^{M - 2} mod M$이다.


2. a + b = c 인 (a, b, c) 개수 찾는 문제면 FFT 시도해보기.


3. 모든 케이스에 대한 경우의 수도 FFT 생각해보기.


4. 순서가 있는 쌍을 찾으라고 하면 정렬한 것과 비교하는 식으로 스위핑일 수 있음. 스위핑이면 보통 세그먼트 트리로 최적화해서 풀 수 있음.


5. 최적화 문제에서 뭔가 안되면, 이분탐색 / 삼분탐색 떠올려보기.


6. 가장 가까운 두 쌍 찾기는 거리를 기준으로 한 분할정복으로 찾을 수 있음.


7. 누가 이기는 건지 묻는걸로 바꿀 수 있으면, 게임이론 -> 스프라그 그런디 정리 쓸 수 있는 지 생각해보기


8. $ dp[i] = max/min(a[i]b[j] + c[j]) + d[i]$ 꼴에, b가 단조증가 단조감소이면 CHT임.

9. 카탈란 수 : 길이가 2n인 올바른 괄호 문자열 수, n + 2각형을 n개 삼각형으로 분할 하는 경우의 수 등으로 나올 수 있음.
$$ C_n = \frac{1}{n + 1} \binom{2n}{n} $$
$$ C_{n + 1} = \sum_{i=0}^{n} C_i C_{n-i} $$
$$ C_{n + 1} = \frac{2(2n+1)}{n+2} C_n $$

\section{DP optimization}

\subsection{Convex Hull Trick}
\lstinputlisting[style=mycpp]{src/dp/CHT.cpp}

DP 아닌데 저런 꼴이 보여도 적용할 수 있음.

만약 a가 단조 증가하지 않으면 구간을 이분탐색으로 찾아주면 됨.

\section{Segment Tree}

\subsection{Segment Tree with Lazy Propagation}
\lstinputlisting[style=mycpp]{src/segment-tree/segtree-lazyprop.cpp}

\subsection{Fenwick Tree}
\lstinputlisting[style=mycpp]{src/segment-tree/fenwick-tree.cpp}

\subsection{Dynamic Segment Tree}
\lstinputlisting[style=mycpp]{src/segment-tree/dynamic-segment-tree.cpp}

\subsection{\_\_gnu\_pbds Ordered Set (can be replaced by k-th segtree)}
\lstinputlisting[style=mycpp]{src/segment-tree/gnu_pbds-ordered-set.cpp}

\section{Graph}

\subsection{Bellman-Ford}
\lstinputlisting[style=mycpp]{src/graph/Bellman-Ford.cpp}

\subsection{SCC(Kosaraju's Algorithm)}
\lstinputlisting[style=mycpp]{src/graph/SCC-Kosaraju.cpp}

\subsection{Heavy-Light Decomposition}
\lstinputlisting[style=mycpp]{src/graph/tree/heavy-light-decomposition.cpp}

\section{Geometry}

\subsection{선분교차 3 (선분교차 여부 + 교점 좌표 출력)}
\lstinputlisting[style=mycpp]{src/geometry/line-cross-test-3.cpp}

\subsection{Convex Hull}
\lstinputlisting[style=mycpp]{src/geometry/convex-hull.cpp}

\subsection{Rotating Calipers}
\lstinputlisting[style=mycpp]{src/geometry/rotating-calipers.cpp}

\subsection{Point in Convex Hull Test}
\lstinputlisting[style=mycpp]{src/geometry/point-in-convex-hull-test.cpp}

\section{String}
\subsection{KMP}
\lstinputlisting[style=mycpp]{src/string/kmp.cpp}

\section{Optimization}
\subsection{GCC pragma}
\lstinputlisting[style=mycpp]{src/etc/opt.cpp}

\section{LCA}
\subsection{LCA}
\lstinputlisting[style=mycpp]{src/graph/tree/lca.cpp}

\section{Mo's}
\subsection{Best Student}
\lstinputlisting[style=mycpp]{src/graph/tree/lca.cpp}

\end{document}